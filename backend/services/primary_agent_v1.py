
import re
import logging

from fastapi import HTTPException
from langchain.agents import initialize_agent, Tool
from langchain.utilities import GoogleSearchAPIWrapper

from services.helpers.question_db import ErrorQuestionRecord

from services.third_platform.stablecoin_agent import stablecoin_agent
from services.third_platform.dex_agent import dex_agent
from services.third_platform.cex_agent import cex_agent
from services.main_project.project_agent import project_agent
from services.main_project.onchain_info_agent import onchain_info_agent

from services.main_project.moonbeam.moonbeam import moonbeam_query_engine

import os
import sys

from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent, AgentOutputParser
from langchain.prompts import StringPromptTemplate
from langchain import OpenAI,  LLMChain
from typing import List, Union
from langchain.schema import AgentAction, AgentFinish, OutputParserException
from core.config import Config

current_directory = os.path.dirname(os.path.realpath(__file__))
backend_directory = os.path.abspath(os.path.join(current_directory,"..",".."))
sys.path.insert(0, backend_directory)

os.environ["OPENAI_API_KEY"] = Config.PRIMARY_AGENT_OPENAI_API_KEY
MODEL_NAME = Config.MODEL_NAME
LLM = OpenAI(temperature=0,model_name=MODEL_NAME)  

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)



# Set up the base template
PRIMARY_AGENT_PROMPT = """
As an investment analysis expert, please answer the following questions using language and perspectives that align with the field. 
Your responses should include summary text and image links where applicable. If you encounter an image link, remember that the valid format should resemble '[Chart Name](https://demo.chatdatainsight.com/api/static/image/chart_2023-07-11_16_Za3qvS3H.png)'. 
However, please note that the provided example is not a valid image link, and you must extract a valid link from the answer generated by the tool. If no images are available, there is no need to include an image link in your response. 
Please avoid using special characters such as '-'. 
Ensure that your answers are based on the content observed without improvisation. 
Remember not to overlook the image link and do not modify it; it must be a valid image link that you have observed. This is crucial for the user experience.

You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the {input} to the action, {input} is the question itself. Please do not modify it.
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin! Remember to speak as a pirate when giving your final answer. Use lots of "Arg"s

Question: {input}
{agent_scratchpad}"""

# Set up a prompt template
class CustomPromptTemplate(StringPromptTemplate):
    # The template to use
    template: str
    # The list of tools available
    tools: List[Tool]

    def format(self, **kwargs) -> str:
        # Get the intermediate steps (AgentAction, Observation tuples)
        # Format them in a particular way
        intermediate_steps = kwargs.pop("intermediate_steps")
        thoughts = ""
        for action, observation in intermediate_steps:
            thoughts += action.log
            thoughts += f"\nObservation: {observation}\nThought: "
        # Set the agent_scratchpad variable to that value
        kwargs["agent_scratchpad"] = thoughts
        # Create a tools variable from the list of tools provided
        kwargs["tools"] = "\n".join([f"{tool.name}: {tool.description}" for tool in self.tools])
        # Create a list of tool names for the tools provided
        kwargs["tool_names"] = ", ".join([tool.name for tool in self.tools])
        return self.template.format(**kwargs)

class CustomOutputParser(AgentOutputParser):

    def parse(self, llm_output: str) -> Union[AgentAction, AgentFinish]:
        # Check if agent should finish
        if "Final Answer:" in llm_output:
            return AgentFinish(
                # Return values is generally always a dictionary with a single `output` key
                # It is not recommended to try anything else at the moment :)
                return_values={"output": llm_output.split("Final Answer:")[-1].strip()},
                log=llm_output,
            )
        # Parse out the action and action input
        regex = r"Action\s*\d*\s*:(.*?)\nAction\s*\d*\s*Input\s*\d*\s*:[\s]*(.*)"
        match = re.search(regex, llm_output, re.DOTALL)
        
        if not match:
            raise OutputParserException(f"xxx primary agent could not parse LLM output: `{llm_output}`")
        action = match.group(1).strip()
        action_input = match.group(2)
        # Return the action and action input
        return AgentAction(tool=action, tool_input=action_input.strip(" ").strip('"'), log=llm_output)

def primary_agent(question: str):

    llm = LLM 

    # Define which tools the agent can use to answer user queries
    tools = [
        Tool(name="DEX Trading Data", func=dex_agent, 
            description="Effective for addressing inquiries related to DEX (Decentralized Exchange) data, such as 'What's the trading volume on a specific DEX?' or 'What's the DEX trading data on a particular blockchain?'"),

        Tool(name="Blockchain Project Details", func=project_agent,
            description="Ideal for responding to specific inquiries about a particular blockchain project, such as 'What stablecoins are available on Moonbeam?' or 'How many DApps are currently on the Moon ecosystem?'"),

        Tool(name="Stablecoin Statistics info", func=stablecoin_agent,
            description="Helpful for answering queries related to stablecoin details, such as 'What is the market share of specific stablecoins?' or 'What is the supply volume of certain stablecoins?'"),

        Tool(name="Crypto Token Pricing", func=cex_agent, 
            description="Useful for addressing queries about the token price of a specific project, including price trends, highs and lows, etc. Please keep the image_link as return value."),

        Tool(name="Onchain Data Details", func=onchain_info_agent, 
            description="Useful for addressing questions about specific on-chain details, such as contract info, address details, or transaction records, among others"),
    
        # Tool(
        #     name = "Search something info internet",func=search_on_internet, 
        #     description="This is the final solution when you are unable to find the answer to a question using other tools, and you have no choice but to seek assistance from the public internet."
        # )
    ]


    prompt = CustomPromptTemplate(
        template=PRIMARY_AGENT_PROMPT,
        tools=tools,
        # This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically
        # This includes the `intermediate_steps` variable because that is needed
        input_variables=["input", "intermediate_steps"]
    ) 

    output_parser = CustomOutputParser()

    # LLM chain consisting of the LLM and a prompt
    llm_chain = LLMChain(llm=llm, prompt=prompt)

    tool_names = [tool.name for tool in tools]
    agent = LLMSingleActionAgent(
        llm_chain=llm_chain,
        output_parser=output_parser,
        stop=["\nObservation:"],
        allowed_tools=tool_names,
        max_iterations = 2
    )

    agent_executor = AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=True)

    print("------- question:",question)
    result = agent_executor.run(question)

    print("*** primary agent result:", result)

    return result



# primary_agent_v2('Can you help me check the market share of stablecoin?')

# moonbeam_query_engine("Which stablecoins are available on Moonbeam?")


def search_on_internet(question: str) -> str:
   

    ErrorQuestionRecord.insert_error_data(question, "", "can not find answer")

    os.environ["GOOGLE_CSE_ID"] = "6170c8edfbf634caf"
    os.environ["GOOGLE_API_KEY"] = "AIzaSyDnFWoQElznz9N5frGoVsOuNP55xBBV6zM"


    search = GoogleSearchAPIWrapper()

    tool = Tool(
        name = "Google Search",
        description="Search Google for recent results.",
        func=search.run
    )

    res = tool.run(question)
    
    return res